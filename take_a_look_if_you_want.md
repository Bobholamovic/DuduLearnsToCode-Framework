# 一些杂乱的想法

## 一半是framework，一半是template

这里说的framework是指利用hook一类的技术让代码复用程度尽量高，调用者只需要利用少许暴露出来的API就可以轻松实现强大的功能。相比这些frameworks，这个项目需要开发者做更多的编程工作，比如写一些类的继承、自己写一些辅助的函数之类的，甚至训练过程也需要自己定制。但这其实也带来了一个优势，那就是更高的自由度。

按照我的理解，template是指一些模板文件，把重复性的代码基本都写好，然后剩下的一些代码由使用者根据需要改写和扩充。这无疑给了开发者极大的自由，但如果要更新模板的话则比较费事。在这个项目里，`src/core`文件夹里的东西是全部的核心组件，更新`src/core`不会影响其它部分，从这点上看`src/core`像是一个独立的library（实际上也被实现为一个git submodule的形式，有自己独立的版本控制），这样更新核心功能的时候只需要更新这个文件夹的内容，相对来说也不会太麻烦。

本质上，这个项目还是提供一个可以改写和套用的模板，所以名字是Template而不是Framework。

## 关于`Duck`

`Duck`类在`src/core/factories.py`中，可以说是这个项目一种比较核心的数据结构。其实`Duck`类的出发点很简单，就是对于有些深度学习任务来说，可能需要不止一个模型（例如GAN）、不止一个数据集或者诸如此类，而这些模型、数据集的一部分行为是一致的。比如，现在有两个模型，我想让它们都进入训练模式，那么比起：

```python
model1.train()
model2.train()
```

或者

```python
for model in models:
  model.train()
```

我还是更希望能直接这样写：

```python
model.train()
```

然后就能实现上面两段代码的功能，看上去就好像我只有一个模型一样。如果我能有这样一个`model`的话，除了写法上简洁，还有一个好处就是我之前为单个模型写的代码在一定程度上可以复用了，我不用为了考虑多个模型的情况硬是把所有出现`model`的地方都替换成`for model in models`。当然，这只是针对读取、存储模型状态、或者`model.train()`之类操作而言的，真正使用两个模型，比如使用GAN的生成器和对抗器进行训练的时候，我还是需要把两个models拆开来用。所以，为了让之前的那些旧代码不用做大修改，同时又能适应多个模型、多个数据集之类的新情况，我搞了个`DuckModel`类，名字取自duck typing。这个类本身是一个容器，封装1个以上的`nn.Module`，我对它的要求是，它的部分对外接口需要与被封装的`nn.Module`类一致，同时又支持把容器里面的东西取出来用。`DuckDataLoader`、`DuckOptimizer`、`DuckCriterion`之类的也是基于类似的思想设计的，其中，`DuckOptimizer`中的每个优化器对象都需要绑定`DuckModel`中的一个模型，这也是从实际出发考虑的。

## 关于builders

builders就是建造器，在`src/core/factories.py`中被使用。每个builder都必须是一个可调用对象。在创建模型、优化器等对象的时候，工厂函数会根据一定的规则从Registry中取出合适的建造器。

例如，对于模型工厂来说，首先会在Registry中尝试匹配`MODEL_MODELS_DATASETS_model`，这里的`MODEL`表示当前需要构造的模型名，`MODELS`表示指定的全部模型（如`'UNet+UNet'`），而`DATASET`则表示指定的全部数据集；接着会匹配`MODEL_DATASETS_model`；最后匹配`MODEL_model`。如果匹配成功，工厂就会调用builder构造出对象。如果三次匹配都失败，那么就返回错误。为什么按照这样的顺序进行匹配呢？主要是出于如下考虑：假设模型`M1`，对于数据集`D1`和`D2`需要不同的参数，而当`M1`和另一个模型`M2`一起使用的时候，又需要另外不同的参数。在这种情况下，如果用单一的builder来构造`M1`，可能会让这个builder过于复杂，因此我们可以通过组合不同的`MODELS`和`DATASETS`的条件，从一个“限定条件比较多的builder”逐步查找匹配到一个“限定条件比较少的builder”。

## 关于`OutPathGetter`

`OutPathGetter`这个类在`src/core/misc.py`中，我喜欢用Global Path Controller（gpc）代指一个`OutPathGetter`对象，因为它往往用在全局路径控制。gpc维护一个目录树，这个目录树代表着“在这次程序运行过程中gpc所能看到的目录结构”，而gpc的主要用途也就是管理这个目录树上的路径。使用者可以往gpc中添加新的路径让目录树得到更新，也可以通过gpc构造想要的路径。比如，首先给一个目录`blabla/out/duduisaduck/`打上“标签”，在gpc那里登记一下，我打算叫这个目录`out`。接下来，在项目的其它部分，只需要调用gpc的`get_path`方法就可以往这个被标记过的`out`文件夹里写东西，而不需要把那个路径作为参数传递或者打成硬编码。除此之外，通过在合适的时刻打印目录树，我们还可以即时知道，程序用到了哪些路径，以及这些路径之间的相对关系、目录结构是什么样的。

## 简单的配置系统

这个项目目前提供的配置系统比较简单，主要原因是我对“各部分完全可配置”这样灵活的方式有些难以接受，所以使用builder（其实就是hard coding）分担了一部分配置文件的职能，降低了整体configurable的程度。关于这点更进一步的讨论在[下一节](#code-more-or-config-more)会提到。

配置文件的naming convention是：

```
config_TAG{_SUFFIX}.yaml
```

`{}`里的部分可以省略。如果运行程序时指定了config文件，程序运行后，会在实验目录下创建或找到一个名为`TAG`的文件夹，然后把实验得到的结果都放在里面。而`SUFFIX`则象征着一种更细粒度的划分：同一个`TAG`、不同的`SUFFIX`会导致`TAG`文件夹中存在不同组的实验结果，这些实验结果之间用不同的`SUFFIX`作为后缀区分。比如：`model_best_arch1.pth`、`model_best_arch2.pth`。

目前只支持对配置文件的单级继承，且继承时不能很好处理嵌套配置项。

除了配置文件以外，使用命令行选项设置参数也是完全支持的。需要注意的是，如果命令行选项和配置文件同时指定了一个配置项，那么优先级顺序为：命令行选项指定值>配置文件>命令行选项默认值。

## code more or config more

现有的机制下提供了自由选择的机会：对于一种功能，可以选择通过写builder这种硬编码的手法来实现，也可以选择通过写不同的配置文件来实现。

举个例子，比如现在要新增一个模型`M`，它在数据集`D1`上需要一套参数，在数据集`D2`上需要另一套参数。这里的“参数”可以是模型的输入通道数，也可以是需要的学习率、batch size等等。我认为这些参数其实并不都是一类东西，应该分开讨论：对于类似通道数这样的参数，我认为是属于“模型和数据集确定了之后就基本不变”的内容，因此比较适合硬编码在builder里，而不需要每次都跟着config文件走；而对于学习率、batch size这类超参数，可能是需要不断尝试和调整的，因此属于经常变动的内容，比较适合写在配置文件里。实际上，还有第三类参数，比如数据集在自己电脑上的位置，这种应该是属于设定过一次就几乎不可能再变化的东西，所以我把它们放在`src/constants.py`里。

当然，上面例子里说的只是我自己的风格，其实写builder、写配置文件这两种方式基本上能够相互代替，也并没有强制一定要用哪种方式，甚至所有的参数都从命令行指定也是可以的，全看个人喜好咯。作为一个开发者来说，可能会更希望多写点代码，而不是维护一大堆的配置文件（感觉写代码比写配置文件爽啊），所以可以多写builders；但如果是一个不怎么喜欢写代码的纯炼丹师，可能就会多花些时间鼓捣配置文件。不过总体来说，纯configs似乎比纯builders的解决方案要干净一些，看起来不是那么暴力。